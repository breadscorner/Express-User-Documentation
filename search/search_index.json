{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Welcome! \ud83d\udc4b This documentation will guide you through setting up a Node.js project for building small to medium-scale RESTful APIs using Express.js . The aim is to provide a sustainable structure that simplifies complex projects into smaller, more reusable, and modular components. We will also focus on best practices and various ways to optimize workflow when working collaboratively. Node.js (or informally Node ) is an open-source, cross-platform runtime environment that allows developers to run JavaScript on the server. Node provides an environment to run scripts server-side to produce dynamic web content for the client. Express.js is an unopinionated and fairly minimalist Node web framework that provides a robust set of features to develop production-ready web and mobile applications. Intended Users This documentation is targeted towards the following users: Beginner to intermediate developers who need to setup a backend for a personal project. Software development teams working on small or medium-sized web applications. Prerequisite Knowledge The documentation assumes the following: Working knowledge of JavaScript( ES6 ), HTML, CSS - you are expected to know how to write basic HTML and CSS to make a simple static website. Ability to use the terminal to run simple commands. Working knowledge of Node.js - you should be familiar with using a package manager such as npm or yarn to install Node.js packages or modules. Software Requirements Before proceeding, ensure you have the following installed: Node.js v14.x or later Npm Package Manager v7.x or later Visual Studio Code Although the screenshots provided will be from VS Code, most of the instructions in this documentation are independent of your IDE. IDEs such as Visual Studio , WebStorm , and Atom are also viable alternatives. Procedures Overview The main sections of the documentation are summarized below: Elaboration on Project Structure Configuring Project for Collaboration Installing Express.js Adding Routes Middleware Typographical Conventions Some code snippets may have clickable numbers that can be useful if you do not understand what a specific piece of code does. See an example of this below: const sum = ( numbers ) => { return numbers . reduce (( a , b ) => a + b , 0 ); // (1) }; Return the sum of the numbers in the list. Changes to a previously created files will be highlighted in yellow: const sum = ( numbers ) => { const multiplier = 2 ; return numbers . reduce (( a , b ) => multiplier * ( a + b ), 0 ); }; File names and npm packages will be formatted like: somefile.js . Instructions that require you to run a command in terminal will be formatted like: run some command in the terminal Notes and Warning Messages Throughout the documentation, we will use message blocks to alert you to relevant information. Each possible message block, from most important to least important: Danger Specifies actions that may cause an error or will cause the application to crash. Warning Specifies content that must be read before proceeding. Info Indicates additional information or tips. Success Indicates what success looks like.","title":"Home"},{"location":"#introduction","text":"Welcome! \ud83d\udc4b This documentation will guide you through setting up a Node.js project for building small to medium-scale RESTful APIs using Express.js . The aim is to provide a sustainable structure that simplifies complex projects into smaller, more reusable, and modular components. We will also focus on best practices and various ways to optimize workflow when working collaboratively. Node.js (or informally Node ) is an open-source, cross-platform runtime environment that allows developers to run JavaScript on the server. Node provides an environment to run scripts server-side to produce dynamic web content for the client. Express.js is an unopinionated and fairly minimalist Node web framework that provides a robust set of features to develop production-ready web and mobile applications.","title":"Introduction"},{"location":"#intended-users","text":"This documentation is targeted towards the following users: Beginner to intermediate developers who need to setup a backend for a personal project. Software development teams working on small or medium-sized web applications.","title":"Intended Users"},{"location":"#prerequisite-knowledge","text":"The documentation assumes the following: Working knowledge of JavaScript( ES6 ), HTML, CSS - you are expected to know how to write basic HTML and CSS to make a simple static website. Ability to use the terminal to run simple commands. Working knowledge of Node.js - you should be familiar with using a package manager such as npm or yarn to install Node.js packages or modules.","title":"Prerequisite Knowledge"},{"location":"#software-requirements","text":"Before proceeding, ensure you have the following installed: Node.js v14.x or later Npm Package Manager v7.x or later Visual Studio Code Although the screenshots provided will be from VS Code, most of the instructions in this documentation are independent of your IDE. IDEs such as Visual Studio , WebStorm , and Atom are also viable alternatives.","title":"Software Requirements"},{"location":"#procedures-overview","text":"The main sections of the documentation are summarized below: Elaboration on Project Structure Configuring Project for Collaboration Installing Express.js Adding Routes Middleware","title":"Procedures Overview"},{"location":"#typographical-conventions","text":"Some code snippets may have clickable numbers that can be useful if you do not understand what a specific piece of code does. See an example of this below: const sum = ( numbers ) => { return numbers . reduce (( a , b ) => a + b , 0 ); // (1) }; Return the sum of the numbers in the list. Changes to a previously created files will be highlighted in yellow: const sum = ( numbers ) => { const multiplier = 2 ; return numbers . reduce (( a , b ) => multiplier * ( a + b ), 0 ); }; File names and npm packages will be formatted like: somefile.js . Instructions that require you to run a command in terminal will be formatted like: run some command in the terminal","title":"Typographical Conventions"},{"location":"#notes-and-warning-messages","text":"Throughout the documentation, we will use message blocks to alert you to relevant information. Each possible message block, from most important to least important: Danger Specifies actions that may cause an error or will cause the application to crash. Warning Specifies content that must be read before proceeding. Info Indicates additional information or tips. Success Indicates what success looks like.","title":"Notes and Warning Messages"},{"location":"pages/configuration/","text":"Overview In this section you will explore the use of ESLint and Prettier to standards for writing and formatting code. As is common practice, you will use Prettier to handle formatting-related issues and ESLint for non-formatting (code quality) issues - see Prettier vs. Linters . This is particularly important for teams where collaboration is necessary. Using ESLint and Prettier provide many benefits, for instance 1 : Increased Code Consistency Better Codebase Coherence Detect Problematic Code Patterns Easier Code Formatting Indeed, these benefits are not just limited to development teams, they are equally useful for individuals working on personal projects. When potential employers look at your GitHub projects, one the first things they look at is the coding style. 2 You'll start by installing ESLint and Prettier, then walking through an example of how to start customizing the rules you want to adhere to. Installation & Initial Setup Before you are able to adding code style and formatter rules, you need to install a few packages using the terminal, as outlined below: Prerequisite You will use the touch command for creating files via the command line. touch is native on Linux and Unix systems. If you are on a Windows machine you can install touch globally by running the following command: npm install touch-cli -g Install Prettier: npm install --save-dev prettier Install ESLint: npm install --save-dev eslint Install relevant ESLint dependencies: npm install --save-dev eslint-config-prettier eslint-plugin-prettier Create a .prettierrc.js file in the root of the directory: touch .prettierrc.js Open the .prettierrc.js file created above and add the following formatting rules: module . exports = { semi : true , // (1) tabWidth : 4 , // (2) singleQuote : true , // (3) }; Ensures that semicolons are added at the end of all statements. Specifies the number of spaces per indentation level to be 4. Specifies that single quotes are used instead of double quotes The rules above are some basic settings suggested by Prettier. Click on the numbers on each line to see what each rule means. For a detailed overview of all the possible rules for Prettier, see Prettier Options . Create a .eslint.js file in the root of the directory: touch .eslint.js Open the .eslint.js file created above and add the following: module . exports = { extends : [ 'prettier' ], // (1) plugins : [ 'prettier' ], // (2) rules : { 'prettier/prettier' : [ 'error' ] // (3) }, }; Enables the config from eslint-config-prettier (Step 3 \ud83d\udc46). Turns off some ESLint rules that conflict with Prettier. Registers eslint-plugin-prettier as plugin (Step 3 \ud83d\udc46). Enable a rule that allows you to use Prettier from within ESLint. Development Dependencies In general, Node packages that are only required during development, should be installed using the npm --save-dev flag, as shown in step 1 above. Customization Prettier is highly opinionated which means you have much less fine-tuning control over formatting. On the other hand, ESLint is much less opinionated and hence provides you with more control relating to code-quality standards. Thankfully, well-known companies such as Airbnb and Google have written their own code style guides - see Airbnb JavaScript Style Guide and Google Java Style Guide . ESLint allows you to 'extend' or import the rules from either of the code-styles guides mentioned above. It is worth noting that there is no hard and fast rule for establishing code-style rules and guidelines. As an example, you will use the Airbnb JavaScript Style Guide as a base config and add a custom rule for illustrative purposes. Install and save the necessary peer dependencies to use the Airbnb style guide: npm install --save-dev eslint-config-airbnb-base eslint-plugin-import Add 'airbnb-base' to the extends array in the .eslintrc.js file: module . exports = { extends : [ 'airbnb-base' , 'prettier' ], // (1) plugins : [ 'prettier' ], rules : { 'prettier/prettier' : [ 'error' ] }, }; Imports preconfigured Airbnb style guide rules. Open the package.json file in the root directory and add a script called lint for running ESLint: { ... \"scripts\" : { \"lint\" : \"eslint . --fix --ext .js\" }, ... } This script allows you to use npm run lint to run the ESLint on all JavaScript files in the project. It also silently fixes any fixable issues for you! Create a server.js file in the root of the directory: touch server.js Open server.js and log \"Hello World\" to the console: console . log ( \"Hello World\" ) Run the lint script that you added in step 3 above: npm run lint Verify that the code is reformatted to be consistent with the rules you added to .prettierrc.js : console . log ( 'Hello World' ); Notice, ESLint has automatically fixed some formatting issues for you. ESLint changed the double quotes around Hello World to single quotes and added a semi-colon to the end of the statement. Warning You may have also noticed that ESLint warns you about the use of the console . This is because, by default, the airbnb code style guide that we extended from has chosen to warn developers on the use on the console. ESLint makes it very easy to overwrite any code-style rules you want. To allow the use of the console , see steps 8 & 9 below \ud83d\udc47. (Optional) Append a rule to the .eslintrc.js file that allows the use of the console: module . exports = { extends : [ 'airbnb-base' , 'prettier' ], plugins : [ 'prettier' ], rules : { 'prettier/prettier' : [ 'error' ], 'no-console' : 'off' // (1) }, }; Allow the use of console statements. (Optional) Rerun the lint script and verify that ESLint no longer shows a warning message: npm run lint Congratulations \ud83d\udc4f This is all you need to do to start using ESLint and Prettier in your projects. For a more detailed list of the rules that use for customizing your code style, see ESLint Rules . Extensions for ESLint and Prettier Thankfully VS Code has extensions for both ESLint and Prettier: VS Code ESLint Extension : allows you you see ESLint errors while you code (even before running npm run lint ) VS Code Prettier Extension : allows you to format files automatically, everytime you save them. ESLint and Prettier also support other IDE's and editors: - ESLint Editor Integrations - Prettier Editor Integrations Conclusion By the end of this section, you will have successfully learned the following: The benefits of using tools such as ESLint and Prettier. How to install and setup ESLint and Prettier. How to customize ESLint. Great job \ud83e\udd17. You can go ahead and click on the link below to move on to the next step: Installing Express Why You Should Use ESLint, Prettier & EditorConfig . \u21a9 Enforce your team\u2019s coding style with Prettier and TsLint . \u21a9","title":"Configuration"},{"location":"pages/configuration/#overview","text":"In this section you will explore the use of ESLint and Prettier to standards for writing and formatting code. As is common practice, you will use Prettier to handle formatting-related issues and ESLint for non-formatting (code quality) issues - see Prettier vs. Linters . This is particularly important for teams where collaboration is necessary. Using ESLint and Prettier provide many benefits, for instance 1 : Increased Code Consistency Better Codebase Coherence Detect Problematic Code Patterns Easier Code Formatting Indeed, these benefits are not just limited to development teams, they are equally useful for individuals working on personal projects. When potential employers look at your GitHub projects, one the first things they look at is the coding style. 2 You'll start by installing ESLint and Prettier, then walking through an example of how to start customizing the rules you want to adhere to.","title":"Overview"},{"location":"pages/configuration/#installation-initial-setup","text":"Before you are able to adding code style and formatter rules, you need to install a few packages using the terminal, as outlined below: Prerequisite You will use the touch command for creating files via the command line. touch is native on Linux and Unix systems. If you are on a Windows machine you can install touch globally by running the following command: npm install touch-cli -g Install Prettier: npm install --save-dev prettier Install ESLint: npm install --save-dev eslint Install relevant ESLint dependencies: npm install --save-dev eslint-config-prettier eslint-plugin-prettier Create a .prettierrc.js file in the root of the directory: touch .prettierrc.js Open the .prettierrc.js file created above and add the following formatting rules: module . exports = { semi : true , // (1) tabWidth : 4 , // (2) singleQuote : true , // (3) }; Ensures that semicolons are added at the end of all statements. Specifies the number of spaces per indentation level to be 4. Specifies that single quotes are used instead of double quotes The rules above are some basic settings suggested by Prettier. Click on the numbers on each line to see what each rule means. For a detailed overview of all the possible rules for Prettier, see Prettier Options . Create a .eslint.js file in the root of the directory: touch .eslint.js Open the .eslint.js file created above and add the following: module . exports = { extends : [ 'prettier' ], // (1) plugins : [ 'prettier' ], // (2) rules : { 'prettier/prettier' : [ 'error' ] // (3) }, }; Enables the config from eslint-config-prettier (Step 3 \ud83d\udc46). Turns off some ESLint rules that conflict with Prettier. Registers eslint-plugin-prettier as plugin (Step 3 \ud83d\udc46). Enable a rule that allows you to use Prettier from within ESLint. Development Dependencies In general, Node packages that are only required during development, should be installed using the npm --save-dev flag, as shown in step 1 above.","title":"Installation &amp; Initial Setup"},{"location":"pages/configuration/#customization","text":"Prettier is highly opinionated which means you have much less fine-tuning control over formatting. On the other hand, ESLint is much less opinionated and hence provides you with more control relating to code-quality standards. Thankfully, well-known companies such as Airbnb and Google have written their own code style guides - see Airbnb JavaScript Style Guide and Google Java Style Guide . ESLint allows you to 'extend' or import the rules from either of the code-styles guides mentioned above. It is worth noting that there is no hard and fast rule for establishing code-style rules and guidelines. As an example, you will use the Airbnb JavaScript Style Guide as a base config and add a custom rule for illustrative purposes. Install and save the necessary peer dependencies to use the Airbnb style guide: npm install --save-dev eslint-config-airbnb-base eslint-plugin-import Add 'airbnb-base' to the extends array in the .eslintrc.js file: module . exports = { extends : [ 'airbnb-base' , 'prettier' ], // (1) plugins : [ 'prettier' ], rules : { 'prettier/prettier' : [ 'error' ] }, }; Imports preconfigured Airbnb style guide rules. Open the package.json file in the root directory and add a script called lint for running ESLint: { ... \"scripts\" : { \"lint\" : \"eslint . --fix --ext .js\" }, ... } This script allows you to use npm run lint to run the ESLint on all JavaScript files in the project. It also silently fixes any fixable issues for you! Create a server.js file in the root of the directory: touch server.js Open server.js and log \"Hello World\" to the console: console . log ( \"Hello World\" ) Run the lint script that you added in step 3 above: npm run lint Verify that the code is reformatted to be consistent with the rules you added to .prettierrc.js : console . log ( 'Hello World' ); Notice, ESLint has automatically fixed some formatting issues for you. ESLint changed the double quotes around Hello World to single quotes and added a semi-colon to the end of the statement. Warning You may have also noticed that ESLint warns you about the use of the console . This is because, by default, the airbnb code style guide that we extended from has chosen to warn developers on the use on the console. ESLint makes it very easy to overwrite any code-style rules you want. To allow the use of the console , see steps 8 & 9 below \ud83d\udc47. (Optional) Append a rule to the .eslintrc.js file that allows the use of the console: module . exports = { extends : [ 'airbnb-base' , 'prettier' ], plugins : [ 'prettier' ], rules : { 'prettier/prettier' : [ 'error' ], 'no-console' : 'off' // (1) }, }; Allow the use of console statements. (Optional) Rerun the lint script and verify that ESLint no longer shows a warning message: npm run lint Congratulations \ud83d\udc4f This is all you need to do to start using ESLint and Prettier in your projects. For a more detailed list of the rules that use for customizing your code style, see ESLint Rules . Extensions for ESLint and Prettier Thankfully VS Code has extensions for both ESLint and Prettier: VS Code ESLint Extension : allows you you see ESLint errors while you code (even before running npm run lint ) VS Code Prettier Extension : allows you to format files automatically, everytime you save them. ESLint and Prettier also support other IDE's and editors: - ESLint Editor Integrations - Prettier Editor Integrations","title":"Customization"},{"location":"pages/configuration/#conclusion","text":"By the end of this section, you will have successfully learned the following: The benefits of using tools such as ESLint and Prettier. How to install and setup ESLint and Prettier. How to customize ESLint. Great job \ud83e\udd17. You can go ahead and click on the link below to move on to the next step: Installing Express Why You Should Use ESLint, Prettier & EditorConfig . \u21a9 Enforce your team\u2019s coding style with Prettier and TsLint . \u21a9","title":"Conclusion"},{"location":"pages/glossary/","text":"Term Definition API API stands for Application Programming Interface. It exposes some of an application's code intentionally for use by other applications. Backend The components of a website that handle and store data. They are not visible to the user. Code consistency The conformity or uniformity of the code, often achieved by following an established code style guide. Code style guide An opinionated guide of coding conventions, style, and best practices meant to ensure code consistency within a project. Can also be referred to as coding guidelines, coding standards, or coding conventions. Dependency Additional code required for the current application to run. Development stack The set of languages, libraries, IDEs and tools (including OS, database server and application server) used for application development. Endpoint One end of a communication channel where one system is interacting with another and performs some action. It is function made available through an API Entry point The point in a program that contains the function for starting the program. ES6 ES6 stands for ECMAScript 6, otherwise knowns as ECMAScript 2015. It is the most recent major version of the stadard for JavaScript. ESLint A popular linter for identifying and reporting problem patters found in ECMAScript or JavaScript code. HTTP request & response HTTP stands for Hypertext Transfer Protocol. It is a standard for transferring information from the browser to the server (requests) and data from the server to the browser (responses). IDE IDE stands for integrated development environment. It is the software used for coding that integrates a text editor with additional tools. Linter A tool that analyzes code and flags programming errors, bugs, and stylistic errors. Localhost A default alias referring to the local computer or \"this computer's\" IP address. Package A file or directory that is described by a package.json file; typically exist as Node modules that can be imported and used in an application. Plugin An extension to an existing software that adds additional functionality. Prettier An opinionated code formatter that parses the code and reprints it according to the configured rules. RESTful API An API architectural style that uses HTTP requests to access and use data. Router An Express object that can store multiple endpoints. Used to organize routes and to create modular code. Routing The action of determining what information is display or what action is taken when a user navigates or triggers a specified endpoint or path. Route The path used in the URL to access endpoints. Runtime environment The environment where a program is executed. Server A computer or system that provides resources, data, services, or programs to other computers, known as clients, over a network.","title":"Glossary"},{"location":"pages/installing-express/","text":"Overview This section will focus on helping you set up an Express.js (or informally known as Express ). It is a web application framework for Node.js that is free and open-source. Express is used to provide server-side logic for web and mobile applications. Installation Steps for Express In the introduction, you will have created a new project folder with all of the subfolders and subfolders required. First, we'll install express and any dependencies, and then walk you through how to create an Express server, so you can serve content to your front-end (browser). Install nodemon : npm install --save-dev nodemon Install Express: npm install express Create a src folder in the root directory: mkdir src Create an app.js file in the src directory: touch src/app.js Open the app.js file created above and add the following code: const express = require ( 'express' ); // (1) const app = express (); // (2) const port = 3000 ; // (3) app . get ( '/' , ( req , res ) => { // (4) res . send ( 'Hello World!' ); }); module . exports = app ; // (5) This line of code will import the express module into your app.js entry point file. This line of code will create a new Express application. This line of code will store the number of the port that we will be using to connect to your localhost. The GET method route will allow our application to send the string \"Hello World!\" as a response when we connect to our localhost. You will be learning more about HTTP methods like GET in a later section. Export the Express application so that server.js can use it. Create an server.js file in the root directory: touch server.js Open the server.js file created above and add the following code: const app = require ( './src/app' ); // (1) const port = 3000 ; // (2) app . listen ( port , () => { // (3) console . log ( `\ud83d\ude80 Server started successfully, listening on port ${ port } : http://localhost: ${ port } ` ); }); Import instance of Express Application created in src/app.js . Specify port number for server to listen on. Start server and listen on specified port. Start Express Server In this last section, you will learn how to run your Express server on your localhost . You will be able to see the string \"Hello World\" from earlier in your internet browser by visiting your localhost:3000. Open the package.json file in the root directory and add a script to start Express: { ... \"scripts\" : { \"start\" : \"nodemon server.js\" , // (1) \"lint\" : \"eslint . --fix --ext .js\" }, ... } This script allows you to use npm run start or npm start to start the Express server. Run the script create above to start the Express server: npm start Open your internet browser of choice and type in the URL for the Express server: localhost:3000 Success Once the page loads, you should see \"Hello World!\" in your browser. This means that you have successfully installed and created your first working server! Conclusion By the end of this section, you will have successfully learned the following: How to install Express How to create a working Express server on your localhost Great job \ud83e\udd17. You can go ahead and click on the link below to move on to the next step: Adding Routes","title":"Installing Express"},{"location":"pages/installing-express/#overview","text":"This section will focus on helping you set up an Express.js (or informally known as Express ). It is a web application framework for Node.js that is free and open-source. Express is used to provide server-side logic for web and mobile applications.","title":"Overview"},{"location":"pages/installing-express/#installation-steps-for-express","text":"In the introduction, you will have created a new project folder with all of the subfolders and subfolders required. First, we'll install express and any dependencies, and then walk you through how to create an Express server, so you can serve content to your front-end (browser). Install nodemon : npm install --save-dev nodemon Install Express: npm install express Create a src folder in the root directory: mkdir src Create an app.js file in the src directory: touch src/app.js Open the app.js file created above and add the following code: const express = require ( 'express' ); // (1) const app = express (); // (2) const port = 3000 ; // (3) app . get ( '/' , ( req , res ) => { // (4) res . send ( 'Hello World!' ); }); module . exports = app ; // (5) This line of code will import the express module into your app.js entry point file. This line of code will create a new Express application. This line of code will store the number of the port that we will be using to connect to your localhost. The GET method route will allow our application to send the string \"Hello World!\" as a response when we connect to our localhost. You will be learning more about HTTP methods like GET in a later section. Export the Express application so that server.js can use it. Create an server.js file in the root directory: touch server.js Open the server.js file created above and add the following code: const app = require ( './src/app' ); // (1) const port = 3000 ; // (2) app . listen ( port , () => { // (3) console . log ( `\ud83d\ude80 Server started successfully, listening on port ${ port } : http://localhost: ${ port } ` ); }); Import instance of Express Application created in src/app.js . Specify port number for server to listen on. Start server and listen on specified port.","title":"Installation Steps for Express"},{"location":"pages/installing-express/#start-express-server","text":"In this last section, you will learn how to run your Express server on your localhost . You will be able to see the string \"Hello World\" from earlier in your internet browser by visiting your localhost:3000. Open the package.json file in the root directory and add a script to start Express: { ... \"scripts\" : { \"start\" : \"nodemon server.js\" , // (1) \"lint\" : \"eslint . --fix --ext .js\" }, ... } This script allows you to use npm run start or npm start to start the Express server. Run the script create above to start the Express server: npm start Open your internet browser of choice and type in the URL for the Express server: localhost:3000 Success Once the page loads, you should see \"Hello World!\" in your browser. This means that you have successfully installed and created your first working server!","title":"Start Express Server"},{"location":"pages/installing-express/#conclusion","text":"By the end of this section, you will have successfully learned the following: How to install Express How to create a working Express server on your localhost Great job \ud83e\udd17. You can go ahead and click on the link below to move on to the next step: Adding Routes","title":"Conclusion"},{"location":"pages/middleware/","text":"Overview When a server receives an HTTP request from the client (browser) it usually processes it and eventually returns some information to client via a HTTP response. This is known as the application\u2019s request-response cycle. For a more in-depth understanding on request-response cycles, see The Request/Response Cycle of the Web . In Express, middleware are functions (or logic) that provide a convenient mechanism to handle HTTP requests entering your application. Middleware functions can be chained together to perform a series of logic, one after the other. The last middleware function will typically end the request-response cycle by returning a response to the client. There are five(5) main categories of middleware that express supports, namely: Built-in Third-party Error-handling Application-level Router-level In this section you'll walk through an example of adding several middleware to Express. Using Middleware in Express Add into src/app.js a built-in middleware in that parses incoming requests that contain JSON data: const express = require ( 'express' ); const router = express . Router (); const app = express (); // Middleware app . use ( express . json ()); ... module . exports = app ; This allows Express to handle html form data that are sent to the server via a POST . Install Helmet : npm install helmet Import helmet in src/app.js : const express = require ( 'express' ); const router = express . Router (); const helmet = require ( 'helmet' ); ... module . exports = app ; Load helmet middleware: const express = require ( 'express' ); const router = express . Router (); const app = express (); // Middleware app . use ( express . json ()); app . use ( helmet ()); ... module . exports = app ; Helmet is a third-party middleware that adds some default protection to your Express application by setting various HTTP headers . Define a custom error-handling middleware function: const express = require ( 'express' ); const router = express . Router (); const app = express (); // Middleware app . use ( express . json ()); app . use ( helmet ()); app . use ( function ( err , req , res , next ) { //Extra logic for handling errors res . status ( 500 ). send ( 'Something broke!' ); }); ... module . exports = app ; Error-handling middleware allows you to catch and process errors that occur within the application. Congratulations \ud83d\udc4f That is for middleware! If it interests you, there is a lot more to middleware provided in the Express Middleware Documentation . Conclusion By the end of this section, you will have successfully learned the following: That they are different types of middleware that Express supports How to add built-in, third-party, and error-handling middleware to Express applications. Great job \ud83e\udd17. Check out the next page if you've had any issues getting the project to work: Troubleshooting","title":"Middleware"},{"location":"pages/middleware/#overview","text":"When a server receives an HTTP request from the client (browser) it usually processes it and eventually returns some information to client via a HTTP response. This is known as the application\u2019s request-response cycle. For a more in-depth understanding on request-response cycles, see The Request/Response Cycle of the Web . In Express, middleware are functions (or logic) that provide a convenient mechanism to handle HTTP requests entering your application. Middleware functions can be chained together to perform a series of logic, one after the other. The last middleware function will typically end the request-response cycle by returning a response to the client. There are five(5) main categories of middleware that express supports, namely: Built-in Third-party Error-handling Application-level Router-level In this section you'll walk through an example of adding several middleware to Express.","title":"Overview"},{"location":"pages/middleware/#using-middleware-in-express","text":"Add into src/app.js a built-in middleware in that parses incoming requests that contain JSON data: const express = require ( 'express' ); const router = express . Router (); const app = express (); // Middleware app . use ( express . json ()); ... module . exports = app ; This allows Express to handle html form data that are sent to the server via a POST . Install Helmet : npm install helmet Import helmet in src/app.js : const express = require ( 'express' ); const router = express . Router (); const helmet = require ( 'helmet' ); ... module . exports = app ; Load helmet middleware: const express = require ( 'express' ); const router = express . Router (); const app = express (); // Middleware app . use ( express . json ()); app . use ( helmet ()); ... module . exports = app ; Helmet is a third-party middleware that adds some default protection to your Express application by setting various HTTP headers . Define a custom error-handling middleware function: const express = require ( 'express' ); const router = express . Router (); const app = express (); // Middleware app . use ( express . json ()); app . use ( helmet ()); app . use ( function ( err , req , res , next ) { //Extra logic for handling errors res . status ( 500 ). send ( 'Something broke!' ); }); ... module . exports = app ; Error-handling middleware allows you to catch and process errors that occur within the application. Congratulations \ud83d\udc4f That is for middleware! If it interests you, there is a lot more to middleware provided in the Express Middleware Documentation .","title":"Using Middleware in Express"},{"location":"pages/middleware/#conclusion","text":"By the end of this section, you will have successfully learned the following: That they are different types of middleware that Express supports How to add built-in, third-party, and error-handling middleware to Express applications. Great job \ud83e\udd17. Check out the next page if you've had any issues getting the project to work: Troubleshooting","title":"Conclusion"},{"location":"pages/possible-project-structure/","text":"Possible project structure. This is not written in stone, MVC and other architecture are often highly opinionated. | -- project-name # Root Directory | -- docs/ # Documentation | -- public/ # Publicly Accessible Assets | | -- images/ | | -- js/ # Client-side JavaScript | | -- styles/ # CSS Stylesheets | -- src/ | | -- app.js # Application Entry Point | | -- api/ | | | -- controllers/ # Request Managers | | | -- middleware/ # Intermediary b/w Client Request & Server Response | | | -- routes/ # API Endpoints (URIs) | | -- config/ # Configuration/Settings Files | | -- db/ # Mock Database or Connection to Database | | -- models/ # Database Models | | -- services/ # Services Layer for Business Logic (Talks to Database) | | -- utils/ # Miscellaneous Helper Functions | | -- views/ # Static Template Files (EJS, Pug, or Mustache) | -- test/ # Test Suite | -- .env # Environment Variables | -- .eslintignore | -- .eslintrc.js # Linting Rules | -- .gitignore # Files/Directory Git Should Ignore | -- .prettierignore | -- .prettierrc.js # Code Formatting Rules | -- package.json # Metadata and Package List | -- README.md | -- server.js # Application Server","title":"Possible project structure"},{"location":"pages/project-structure/","text":"Overview When working on a project, it is important to have a clear project structure. Although the importance of having a project structure may seem insignificant when working on a small project, programmers and engineers will often collaborate with each other to write thousands of lines of code. It would be pure chaos if there was no defined project structure to keep all of your code organized. On top of this, troubleshooting issues and implementing new features would be a nightmare. Model-View-Controller (MVC) An MVC is a software design pattern that is used to divide all related program logic into three core logical components called the Model , View , and Controller . The Controller is used to control what View is displayed while using the Model to provide data for the View to render. In this guide we will be using this project structure to guide you towards creating a small to medium-sized project. As your project grows larger, you will want to modify and personalize your project as you find is necessary. Please refer to the example below to see the overview of the project structure: | -- project-name # Root Directory | -- src/ # Application Programming Interfaces | | -- api/ # API Endpoints (URIs) | | | -- routes/ # API Endpoints (URIs) | | | | --app.js # Entry Point File | -- node_modules/ # Downloaded Libraries | -- .eslintrc.js # Linting Rules | -- .prettierrc.js # Code Formatting Rules | -- package.json # Metadata and Package List | -- package-lock.json # Version Number for Dependencies | -- server.js # Server File Create a Subfolder Before we get started, you will want to create a folder where you will store your new express project. This folder is called the root folder (also known as root directory or root ). In this section, you will be creating the subfolder structure for your project. Folders created inside of the root folder are called subfolders. Go ahead and up your project in Visual Studio Code . Type the command below in the Terminal to create a docs folder. mkdir src Create Nested Subfolders After you have created your first subfolder in the project, we will be creating more folders inside of the src folder. The newly created folders are called nested subfolders. The source (src) folder will contain all of the files needed to build your project. Type the command below to move into your src directory. cd src Type the command below to create an api folder inside the src . mkdir api Type the command below to move into your api directory. cd api Type the command below to create routes folder inside the api folder. mkdir routes Medium to Large Projects Here is an example of a medium to larger scaled project. You can choose what kinds of folders will be required for your personalized project. | -- project-name | -- node_modules/ | -- public/ | | -- images/ | | -- js/ | | -- styles/ | -- src/ | | -- api/ | | | -- controllers/ | | | -- middleware/ | | | -- routes/ | | -- config/ | | -- db/ | | -- models/ | | -- services/ | | -- utils/ | | -- views/ | -- .eslintrc.js | -- .prettierrc.js | -- package.json | -- package-lock.json Test Subfolder Recommendation Another folder that we highly recommend creating is a test subfolder. As your projects get bigger, you will find that testing your applications will make it easier to maintain your code. Although it is not always necessary for smaller projects, it is considered good practice to use test suites to test your application. Conclusion By the end of this section, you will have successfully learned the following: Why project structure is important How to organize the subfolders How to organize nested subfolders Congratulations! \ud83c\udf89 You can go ahead and click on the link below to learn more about how to configure your project: Configuration","title":"Project Structure"},{"location":"pages/project-structure/#overview","text":"When working on a project, it is important to have a clear project structure. Although the importance of having a project structure may seem insignificant when working on a small project, programmers and engineers will often collaborate with each other to write thousands of lines of code. It would be pure chaos if there was no defined project structure to keep all of your code organized. On top of this, troubleshooting issues and implementing new features would be a nightmare. Model-View-Controller (MVC) An MVC is a software design pattern that is used to divide all related program logic into three core logical components called the Model , View , and Controller . The Controller is used to control what View is displayed while using the Model to provide data for the View to render. In this guide we will be using this project structure to guide you towards creating a small to medium-sized project. As your project grows larger, you will want to modify and personalize your project as you find is necessary. Please refer to the example below to see the overview of the project structure: | -- project-name # Root Directory | -- src/ # Application Programming Interfaces | | -- api/ # API Endpoints (URIs) | | | -- routes/ # API Endpoints (URIs) | | | | --app.js # Entry Point File | -- node_modules/ # Downloaded Libraries | -- .eslintrc.js # Linting Rules | -- .prettierrc.js # Code Formatting Rules | -- package.json # Metadata and Package List | -- package-lock.json # Version Number for Dependencies | -- server.js # Server File","title":"Overview"},{"location":"pages/project-structure/#create-a-subfolder","text":"Before we get started, you will want to create a folder where you will store your new express project. This folder is called the root folder (also known as root directory or root ). In this section, you will be creating the subfolder structure for your project. Folders created inside of the root folder are called subfolders. Go ahead and up your project in Visual Studio Code . Type the command below in the Terminal to create a docs folder. mkdir src","title":"Create a Subfolder"},{"location":"pages/project-structure/#create-nested-subfolders","text":"After you have created your first subfolder in the project, we will be creating more folders inside of the src folder. The newly created folders are called nested subfolders. The source (src) folder will contain all of the files needed to build your project. Type the command below to move into your src directory. cd src Type the command below to create an api folder inside the src . mkdir api Type the command below to move into your api directory. cd api Type the command below to create routes folder inside the api folder. mkdir routes Medium to Large Projects Here is an example of a medium to larger scaled project. You can choose what kinds of folders will be required for your personalized project. | -- project-name | -- node_modules/ | -- public/ | | -- images/ | | -- js/ | | -- styles/ | -- src/ | | -- api/ | | | -- controllers/ | | | -- middleware/ | | | -- routes/ | | -- config/ | | -- db/ | | -- models/ | | -- services/ | | -- utils/ | | -- views/ | -- .eslintrc.js | -- .prettierrc.js | -- package.json | -- package-lock.json Test Subfolder Recommendation Another folder that we highly recommend creating is a test subfolder. As your projects get bigger, you will find that testing your applications will make it easier to maintain your code. Although it is not always necessary for smaller projects, it is considered good practice to use test suites to test your application.","title":"Create Nested Subfolders"},{"location":"pages/project-structure/#conclusion","text":"By the end of this section, you will have successfully learned the following: Why project structure is important How to organize the subfolders How to organize nested subfolders Congratulations! \ud83c\udf89 You can go ahead and click on the link below to learn more about how to configure your project: Configuration","title":"Conclusion"},{"location":"pages/routes/","text":"Overview In this section, we will walk you through how to set up your first routes for your Express server. Afterwards, we will see how we can clean up the code using routers . Routes & HTTP Requests In Express, a route interprets the HTTP request method made to the server. Routing is the action of determining what information is display or what action is taken when a user navigates or triggers a specified endpoint or path . A simple route comprises the following components app : the instance of Express that you have created in Getting Started method : the Express route method corresponding to HTTP requests (eg. get , post , or put ) path : the defined endpoint of the request handler : the function that is called when the route is hit Handler functions The handler will often be an anonymous function written as either a regular function or an arrow function . You may see more than one handler function per route in more complex routes. GET & POST The GET method is used to request data from a server. The POST method is used to send data to create date or update data on a server. 1 We left off in Installing Express with one route already set up to the root directory ( '/' ) from src/app.js . The handler for this route is an anonymous function that takes in two parameters. The first parameter represents the HTTP request object (often written as request or req ) and the second parameter is the response object (written as response or res ). A response method is called in the handler to terminate the request-response cycle. const express = require ( 'express' ); const app = express (); app . get ( '/' , ( req , res ) => { // (1) res . send ( 'Hello World!' ); // (2) }); module . exports = app ; '/' (forward slash) is your root directory. res.send() can send back various types of content. Info Remember you can click on the numbers at the end of a line of code for extra information about the specific examples used. Returning a Static Webpage Using GET As an example, let's create a route to display a contact page in the form of a static HTML page. Start with the route method and insert the path for your Express server to listen for. app . get ( '/contact' ); Insert an empty handler that has the parameters for the request and response objects app . get ( '/contact' , ( req , res ) => { }); Insert the action you want to perform into the handler function: app . get ( '/contact' , ( req , res ) => { res . sendFile ( 'contact.html' ); // (1) }); Use res.sendFile() to serve a static HTML page. Sending Data Using POST Suppose you have a form on your contact page for users to submit a message. You would use a POST request so that you can retrieve the submitted data and store it somewhere. Action & Name Attributes The action attribute must match the path that will match the route path where we insert the handler logic. The name attribute for each input will become the key/property of the object that the form will send to your server. Start with the route method and insert the path for your Express server to listen for. app . post ( '/contact' ); Note that you can use the same path with different methods to perform different actions. Insert an empty handler that has the parameters for the request and response objects app . post ( '/contact' , ( req , res ) => { }); Insert the action you want to perform into the handler function. app . post ( '/contact' , ( req , res ) => { const email = req . body . email ; // (1) const message = req . body . message ; // code to process the form data res . redirect ( '/confirmation' ); // (2) }); req.body` it the object containing the input names and values from the form that was posted. Use res.redirect() to redirect your user to another page/route to end your handler function. Success At this point, you have the tools to set up many routes in your app.js. Next we will cover how to refactor your routes so app.js` is more manageable. const express = require ( 'express' ); const app = express (); app . get ( '/' , ( req , res ) => { res . send ( 'Hello World!' ); }) app . get ( '/contact' , ( req , res ) => { res . sendFile ( 'contact.html' ); }); app . post ( '/contact' , ( req , res ) => { const email = req . body . email ; const message = req . body . message ; // code to process the form data res . redirect ( '/confirmation' ); }); app . get ( '/reviews' , ( req , res ) => { res . sendFile ( 'reviews.html' ); }); app . get ( '/reviews/add' , ( req , res ) => { // (1) // code to add a review res . redirect ( '/reviews' ); }); app . get ( '/reviews/delete' , ( req , res ) => { // code to delete a review res . redirect ( '/reviews' ); }); module . exports = app ; Note that you can use multi-level paths as well. Setting up Routers As the scope of your project grows or scales, you may find the need to organize your routes for ease of maintenance. Express provides a class to help achieve this called a Router . If you had several related endpoints, it would be more manageable to organize these related routes into their own file. The Express router can help you achieve this by allowing you to export this grouping into another file (in our case app.js ). This file acts as a main hub directing requests to the appropriate endpoints. Router Example We will add onto our previous example with the contact page routes. At the moment, these routes are in src/app.js . We want to move the contact routes to their own file for better organization. Create a new JavaScript File called contactRoute.js in src/api/routes . You can technically make this file anywhere you wish in your project but for this example, we will use this project structure . Require Express into contactRoute.js and create a new instance of the Router class by storing it to a new variable ( router ). const express = require ( 'express' ); // (1) const router = express . Router (); // (2) Import the Express module so we can access its properties Make a new instance of the built-in Router class that will hold the routes we assign to it. Cut and paste the two contact routes from app.js into the contactRoute.js file. const express = require ( 'express' ); const router = express . Router (); app . get ( '/contact' , ( req , res ) => { res . sendFile ( 'contact.html' ); }); app . post ( '/contact' , function ( req , res ) { const email = req . body . email ; const message = req . body . message ; // code to process the form data res . redirect ( '/confirmation' ); }); Change app to router so that the routes are now associated to this router instance. We can remove 'contact' from our path now as we will be setting the 'contact' path in app.js . const express = require ( 'express' ); const router = express . Router (); router . get ( '/' , function ( req , res ) { res . sendFile ( 'contact.html' ); }); router . post ( '/' , function ( req , res ) { const email = req . body . email ; const message = req . body . message ; // code to process the form data res . redirect ( '/confirmation' ); }); Add an export to the end of the file so we can access this router and its associated routes from other files. const express = require ( 'express' ); const router = express . Router (); router . get ( '/contact' , function ( req , res ) { res . sendFile ( 'contact.html' ); }); router . post ( '/contact' , function ( req , res ) { const email = req . body . email ; const message = req . body . message ; // code to process the form data res . redirect ( '/confirmation' ); }); module . exports = router ; // (1) Your routes have been set to this variable so we only have to export the router and not the individual routes. Import the contact router into app.js . const express = require ( 'express' ); const app = express (); const contactRoute = require ( 'api/routes/contactRoute' ); // (1) module . exports = app ; Make sure you are requiring your router from wherever you have placed your contactRoute.js in your project. Use app.use() to load the router into the Express app. Paths that start with /contact will now be sent to contactRoute.js for further routing. const express = require ( 'express' ); const app = express (); const contactRoute = require ( 'api/routes/contactRoute' ); app . use ( '/contact' , contactRoute ); // (1) module . exports = app ; app.use() tells Express what functions you want to associate with the path in the first parameter. Success You can have many router files in your project that you can import into another file for use. This will keep your files a mangeable size for readability. const express = require ( 'express' ); const app = express (); // Routes const indexRoute = require ( 'api/routes/indexRoute' ); const contactRoute = require ( 'api/routes/contactRoute' ); const authRoute = require ( 'api/routes/authRoute' ); const reviewsRoute = require ( 'api/routes/reviewsRoute' ); // Route Matchers app . use ( '/' , indexRoute ); app . use ( '/contact' , contactRoute ); app . use ( '/auth' , authRoute ); app . use ( '/reviews' , reviewsRoute ); // (1) module . exports = app ; The reviews/add and reviews/delete paths now exist in a reviewRoute.js file as /add and /delete . Conclusion By the end of this section, you will have successfully learned the following: How to write a route to set the desired response to different HTTP requests How to use the Express Router class to group routes How to export and import the router for use in separate file Great job \ud83e\udd17. You can go ahead and click on the link below to move on to the next step: Using Middleware HTTP Request Methods . \u21a9","title":"Routes & Routers"},{"location":"pages/routes/#overview","text":"In this section, we will walk you through how to set up your first routes for your Express server. Afterwards, we will see how we can clean up the code using routers . Routes & HTTP Requests In Express, a route interprets the HTTP request method made to the server. Routing is the action of determining what information is display or what action is taken when a user navigates or triggers a specified endpoint or path . A simple route comprises the following components app : the instance of Express that you have created in Getting Started method : the Express route method corresponding to HTTP requests (eg. get , post , or put ) path : the defined endpoint of the request handler : the function that is called when the route is hit Handler functions The handler will often be an anonymous function written as either a regular function or an arrow function . You may see more than one handler function per route in more complex routes. GET & POST The GET method is used to request data from a server. The POST method is used to send data to create date or update data on a server. 1 We left off in Installing Express with one route already set up to the root directory ( '/' ) from src/app.js . The handler for this route is an anonymous function that takes in two parameters. The first parameter represents the HTTP request object (often written as request or req ) and the second parameter is the response object (written as response or res ). A response method is called in the handler to terminate the request-response cycle. const express = require ( 'express' ); const app = express (); app . get ( '/' , ( req , res ) => { // (1) res . send ( 'Hello World!' ); // (2) }); module . exports = app ; '/' (forward slash) is your root directory. res.send() can send back various types of content. Info Remember you can click on the numbers at the end of a line of code for extra information about the specific examples used.","title":"Overview"},{"location":"pages/routes/#returning-a-static-webpage-using-get","text":"As an example, let's create a route to display a contact page in the form of a static HTML page. Start with the route method and insert the path for your Express server to listen for. app . get ( '/contact' ); Insert an empty handler that has the parameters for the request and response objects app . get ( '/contact' , ( req , res ) => { }); Insert the action you want to perform into the handler function: app . get ( '/contact' , ( req , res ) => { res . sendFile ( 'contact.html' ); // (1) }); Use res.sendFile() to serve a static HTML page.","title":"Returning a Static Webpage Using GET"},{"location":"pages/routes/#sending-data-using-post","text":"Suppose you have a form on your contact page for users to submit a message. You would use a POST request so that you can retrieve the submitted data and store it somewhere. Action & Name Attributes The action attribute must match the path that will match the route path where we insert the handler logic. The name attribute for each input will become the key/property of the object that the form will send to your server. Start with the route method and insert the path for your Express server to listen for. app . post ( '/contact' ); Note that you can use the same path with different methods to perform different actions. Insert an empty handler that has the parameters for the request and response objects app . post ( '/contact' , ( req , res ) => { }); Insert the action you want to perform into the handler function. app . post ( '/contact' , ( req , res ) => { const email = req . body . email ; // (1) const message = req . body . message ; // code to process the form data res . redirect ( '/confirmation' ); // (2) }); req.body` it the object containing the input names and values from the form that was posted. Use res.redirect() to redirect your user to another page/route to end your handler function. Success At this point, you have the tools to set up many routes in your app.js. Next we will cover how to refactor your routes so app.js` is more manageable. const express = require ( 'express' ); const app = express (); app . get ( '/' , ( req , res ) => { res . send ( 'Hello World!' ); }) app . get ( '/contact' , ( req , res ) => { res . sendFile ( 'contact.html' ); }); app . post ( '/contact' , ( req , res ) => { const email = req . body . email ; const message = req . body . message ; // code to process the form data res . redirect ( '/confirmation' ); }); app . get ( '/reviews' , ( req , res ) => { res . sendFile ( 'reviews.html' ); }); app . get ( '/reviews/add' , ( req , res ) => { // (1) // code to add a review res . redirect ( '/reviews' ); }); app . get ( '/reviews/delete' , ( req , res ) => { // code to delete a review res . redirect ( '/reviews' ); }); module . exports = app ; Note that you can use multi-level paths as well.","title":"Sending Data Using POST"},{"location":"pages/routes/#setting-up-routers","text":"As the scope of your project grows or scales, you may find the need to organize your routes for ease of maintenance. Express provides a class to help achieve this called a Router . If you had several related endpoints, it would be more manageable to organize these related routes into their own file. The Express router can help you achieve this by allowing you to export this grouping into another file (in our case app.js ). This file acts as a main hub directing requests to the appropriate endpoints.","title":"Setting up Routers"},{"location":"pages/routes/#router-example","text":"We will add onto our previous example with the contact page routes. At the moment, these routes are in src/app.js . We want to move the contact routes to their own file for better organization. Create a new JavaScript File called contactRoute.js in src/api/routes . You can technically make this file anywhere you wish in your project but for this example, we will use this project structure . Require Express into contactRoute.js and create a new instance of the Router class by storing it to a new variable ( router ). const express = require ( 'express' ); // (1) const router = express . Router (); // (2) Import the Express module so we can access its properties Make a new instance of the built-in Router class that will hold the routes we assign to it. Cut and paste the two contact routes from app.js into the contactRoute.js file. const express = require ( 'express' ); const router = express . Router (); app . get ( '/contact' , ( req , res ) => { res . sendFile ( 'contact.html' ); }); app . post ( '/contact' , function ( req , res ) { const email = req . body . email ; const message = req . body . message ; // code to process the form data res . redirect ( '/confirmation' ); }); Change app to router so that the routes are now associated to this router instance. We can remove 'contact' from our path now as we will be setting the 'contact' path in app.js . const express = require ( 'express' ); const router = express . Router (); router . get ( '/' , function ( req , res ) { res . sendFile ( 'contact.html' ); }); router . post ( '/' , function ( req , res ) { const email = req . body . email ; const message = req . body . message ; // code to process the form data res . redirect ( '/confirmation' ); }); Add an export to the end of the file so we can access this router and its associated routes from other files. const express = require ( 'express' ); const router = express . Router (); router . get ( '/contact' , function ( req , res ) { res . sendFile ( 'contact.html' ); }); router . post ( '/contact' , function ( req , res ) { const email = req . body . email ; const message = req . body . message ; // code to process the form data res . redirect ( '/confirmation' ); }); module . exports = router ; // (1) Your routes have been set to this variable so we only have to export the router and not the individual routes. Import the contact router into app.js . const express = require ( 'express' ); const app = express (); const contactRoute = require ( 'api/routes/contactRoute' ); // (1) module . exports = app ; Make sure you are requiring your router from wherever you have placed your contactRoute.js in your project. Use app.use() to load the router into the Express app. Paths that start with /contact will now be sent to contactRoute.js for further routing. const express = require ( 'express' ); const app = express (); const contactRoute = require ( 'api/routes/contactRoute' ); app . use ( '/contact' , contactRoute ); // (1) module . exports = app ; app.use() tells Express what functions you want to associate with the path in the first parameter. Success You can have many router files in your project that you can import into another file for use. This will keep your files a mangeable size for readability. const express = require ( 'express' ); const app = express (); // Routes const indexRoute = require ( 'api/routes/indexRoute' ); const contactRoute = require ( 'api/routes/contactRoute' ); const authRoute = require ( 'api/routes/authRoute' ); const reviewsRoute = require ( 'api/routes/reviewsRoute' ); // Route Matchers app . use ( '/' , indexRoute ); app . use ( '/contact' , contactRoute ); app . use ( '/auth' , authRoute ); app . use ( '/reviews' , reviewsRoute ); // (1) module . exports = app ; The reviews/add and reviews/delete paths now exist in a reviewRoute.js file as /add and /delete .","title":"Router Example"},{"location":"pages/routes/#conclusion","text":"By the end of this section, you will have successfully learned the following: How to write a route to set the desired response to different HTTP requests How to use the Express Router class to group routes How to export and import the router for use in separate file Great job \ud83e\udd17. You can go ahead and click on the link below to move on to the next step: Using Middleware HTTP Request Methods . \u21a9","title":"Conclusion"},{"location":"pages/snippets/","text":"Possible project structure. This is not written in stone, MVC and other architecture are often highly opinionated. | -- project-name # Root Directory | -- docs/ # Documentation | -- public/ # Publicly Accessible Assets | | -- images/ | | -- js/ # Client-side JavaScript | | -- styles/ # CSS Stylesheets | -- src/ | | -- app.js # Application Entry Point | | -- api/ | | | -- controllers/ # Request Managers | | | -- middleware/ # Intermediary b/w Client Request & Server Response | | | -- routes/ # API Endpoints (URIs) | | -- config/ # Configuration/Settings Files | | -- db/ # Mock Database or Connection to Database | | -- models/ # Database Models | | -- services/ # Services Layer for Business Logic (Talks to Database) | | -- utils/ # Miscellaneous Helper Functions | | -- views/ # Static Template Files (EJS, Pug, or Mustache) | -- test/ # Test Suite | -- .env # Environment Variables | -- .eslintignore | -- .eslintrc.js # Linting Rules | -- .gitignore # Files/Directory Git Should Ignore | -- .prettierignore | -- .prettierrc.js # Code Formatting Rules | -- package.json # Metadata and Package List | -- README.md | -- server.js # Application Server /** .eslintrc.js */ module . exports = { extends : 'airbnb-base' , // (1) env : { // (2) browser : true , commonjs : true , node : true , es6 : true , jquery : true , }, rules : { indent : [ 'error' , 4 ], // (3) 'linebreak-style' : 0 , // (4) 'max-len' : [ 'error' , { code : 120 }], // (5) 'max-lines-per-function' : [ 'error' , { max : 35 , skipComments : true }], // (6) 'max-nested-callbacks' : [ 'error' , 2 ], // (7) 'no-console' : 'off' , // (8) }, }; Inherit all rules from airbnb code styleguide . Environments that provide predefined global variables - see ESLint Environments for a complete list of supported environments. Enforces consistent indentation (4 spaces). Enforces consistent linebreak style. Enforces a maximum line length of 120 characters. Enforces a maximum function length of 35 lines. Enforces a maximum depth or 3 that callbacks can be nested. A common pitfall that is easy to fall into is nesting callbacks, which makes code more difficult to read the deeper the callbacks are nested. Allows the use of console. /** .prettierrc.js */ module . exports = { trailingComma : \"es5\" , tabWidth : 4 , semi : true , singleQuote : true , }; /** /src/app.js */ const express = require ( 'express' ); // (1) const app = express (); // (2) app . get ( '/' , ( req , res ) => { // (3) res . send ( 'Hello World' ); // (4) }); module . exports = app ; Import Express module Create Express application Handle GET request made for the root URL. req is the incoming request and res is used to send back the desired HTTP response. Return a message of 'Hello World' in response to the HTTP request. Note, express supports methods that correspond to each HTTP request method ( GET , POST , PUT , DELETE , etc. ). For a refresher on the different HTTP request methods, see here . /** server.js */ const app = require ( './src/app' ); // (1) const port = process . env . PORT || 3000 ; // (2) app . listen ( port , () => { // (3) console . log ( `\ud83d\ude80 Server started successfully, listening on port ${ port } ` ); }); Import instance of Express Application created in /src/app.js . Specify port number for server to listen on. Start server and listen on specified port.","title":"Snippets"},{"location":"pages/troubleshooting/","text":"Symptoms Probable Cause Action Unable to load the localhost page Your URL does not match your port number. Double check what port you have set in server.js and if your browser URL is localhost:PORT with PORT being the number you have set. You forgot to tell the Express app to listen to a port number. Make sure you have app.listen(port, () => {}) in server.js to configure which port you want Express to watch. You have another app running on the same port. Close any additional servers that might be running. Only one app per port is possible. ESLint warns you about the use of the console You have not configured ESLint to accept console.log . Make sure you have rules: {'no-console': 'off' }, set in .eslintrc.js as directed in Eslint Customization \"TypeError: app.listen is not a function\" or similar You forgot to export one of your modules (ie. app or router). Make sure you have module.exports = router; at the end of your router files and module.exports = app; where you created your new Express app. \"Error: Cannot find module '<NAME>'\" You're requiring the module from the wrong path. Double check the path in the require(PATH) is pointing to the correct location. localhost is loading indefinitely You forgot to include (or you are not hitting) a response method. Make sure the handler function includes a response method to end the HTTP request-response cycle.","title":"Troubleshooting"}]}